#include <iostream>

using namespace std;

int vals[10];
int error = -1;

int &put(int n);

/**
 * cin,cout,cerr定义：
 * 1. cin是C++编程语言中的标准输入流对象，即istream类的对象。cin主要用于从标准输入读取数
 * 据，这里的标准输入，指的是终端或键盘。
 * 2. cout是流的对象，即ostream类的对象
 * 3. cerr是标准错误输出流的对象，也是ostream 类的对象。这里的标准输出指的是终端键盘，标准错误输出指的是终端的屏幕。
 * 在理解cin功能时，不得不提标准输入缓冲区。当我们从键盘输入字符串的时候需要敲一下回车键
 * 才能够将这个字符串送入到缓冲区中，那么敲入的这个回车键(\r)会被转换为一个换行符\n，这个换行符\n也会被存储在cin的缓冲区中并且被当成一个字符来计算！
 * 比如我们在键盘上敲下了123456这个字符串，然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是7 ，而不是6。
 *
 * cin读取数据也是从缓冲区中获取数据，缓冲区为空时，cin的成员函数会阻塞等待数据的到来，一旦缓冲区中有数据，就触发cin的成员函数去读取数据。
 *
 * C++的iostream库和C中的stdio库中分别的cout/cin和printf/scanf相比有哪些优势呢？首先是类型处理更加安全，更加智能。我们无须应对int、float中的%d、%f，
 * 而且扩展性极强，对于新定义的类，printf想要输入输出一个自定义的类的成员是天方夜谭的，而iostream中使用的位运算符都是可重载的，并且可以将清空缓冲区的
 * 自由交给了用户（在printf中的输出是没有缓冲区的），而且流风格的写法也更加自然和简洁。
 **/

/**
 *  引用的定义：
 *  引用：就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样。
 *  引用的声明方法：类型标识符 &引用名=目标变量名；
 * （1）&在此不是求地址运算符，而是起标识作用。
 * （2）声明引用时，必须同时对其进行初始化。
 * （3）类型标识符是指目标变量的类型。
 * （4）引用声明完毕后，相当于目标变量有两个名称即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。
 * （5）声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也
 *     不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&ra与&a相等。
 * （6）不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。
 */

void cincout()
{

    int a = 5;
    int &b = a;
    b = 6;
    cout << "a=" << a << ",b=" << b << endl; // a=6,b=6 改了b，就相当于改了a
    int c = 7;
    b = c;
    cout << "a=" << a << ",b=" << b << endl; // a=7,b=7
}

/**
 * （1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的
 * 实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在
 * 主调函数中）的操作。
 * （2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一
 * 般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；
 * 如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传
 * 递参数的效率和所占空间都好。
 * （3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参
 * 分配存储单元，且需要重复使用"*指针变量名"的形式进行运算，这很容易产生错误且程序的阅读性较
 * 差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。
 * */
void swap(int &p1, int &p2)
{
    int p = p1;
    p1 = p2;
    p2 = p;
}

void bar(string &s)
{
}

int main()
{
    // char c1, c2;
    // int a;
    // float b;
    // std::cin >> c1 >> c2 >> a >> b;

    // std::cout << c1 << c2 << a << b;

    // cincout();

    int a = 1, b = 2;
    swap(a, b); // 直接以a和b作为实参调用swap函数
    cout << "a=" << a << ",b=" << b << endl;

    const int &c = a;
    // c = 3;  //报错
    a = 3; // 这种是可以的
    cout << "a=" << a << "&c=" << c << endl;

    // 原因在于foo( )和"hello world"串都会产生一个临时对象，而在C++中，临时对象都是const类型
    // 的。因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。
    // bar("hello world"); 不能这样赋值

    put(0) = 10;             // 以put(0)函数值作为左值，等价于vals[0]=10;
    put(9) = 20;             // 以put(9)函数值作为左值，等价于vals[9]=20;
    cout << vals[0] << endl; // 10
    cout << vals[9] << endl; // 20

    return 0;
}

// （1）以引用返回函数值，定义函数时需要在函数名前加&
// （2）用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。
//  主要注意：
// （1）不能返回局部变量的引用
// （2）不能返回函数内部new分配的内存的引用

int &put(int n)
{
    if (n >= 0 && n <= 9)
        return vals[n];
    else
    {
        cout << "subscript error";
        return error;
    }
}